// This file is generated by Breeze.JS Bindgen (https://github.com/breeze-shell/breeze-js-bindgen)
// Do not modify this file manually!

#pragma once
#include "binding_types.h"
#include "quickjspp.hpp"

template <typename T>
struct js_bind {
    static void bind(qjs::Context::Module &mod) {}
};

template <> struct qjs::js_traits<breeze::js::filesystem> {
    static breeze::js::filesystem unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::filesystem obj;

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::filesystem &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        return obj;
    }
};
template<> struct js_bind<breeze::js::filesystem> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::filesystem>("filesystem")
            .constructor<>()
                .static_fun<&breeze::js::filesystem::readFileAsStringSync>("readFileAsStringSync")
                .static_fun<&breeze::js::filesystem::readFileAsString>("readFileAsString")
                .static_fun<&breeze::js::filesystem::readdir>("readdir")
                .static_fun<&breeze::js::filesystem::readdirSync>("readdirSync")
                .static_fun<&breeze::js::filesystem::mkdir>("mkdir")
                .static_fun<&breeze::js::filesystem::mkdirSync>("mkdirSync")
                .static_fun<&breeze::js::filesystem::exists>("exists")
                .static_fun<&breeze::js::filesystem::rm>("rm")
                .static_fun<&breeze::js::filesystem::rmSync>("rmSync")
                .static_fun<&breeze::js::filesystem::writeStringToFile>("writeStringToFile")
            ;
    }
};

template <> struct qjs::js_traits<breeze::js::filesystem::ReadDirOptions> {
    static breeze::js::filesystem::ReadDirOptions unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::filesystem::ReadDirOptions obj;

        obj.recursive = js_traits<bool>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "recursive"));

        obj.follow_symlinks = js_traits<bool>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "follow_symlinks"));

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::filesystem::ReadDirOptions &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        JS_SetPropertyStr(ctx, obj, "recursive", js_traits<bool>::wrap(ctx, val.recursive));

        JS_SetPropertyStr(ctx, obj, "follow_symlinks", js_traits<bool>::wrap(ctx, val.follow_symlinks));

        return obj;
    }
};
template<> struct js_bind<breeze::js::filesystem::ReadDirOptions> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::filesystem::ReadDirOptions>("filesystem::ReadDirOptions")
            .constructor<>()
                .fun<&breeze::js::filesystem::ReadDirOptions::recursive>("recursive")
                .fun<&breeze::js::filesystem::ReadDirOptions::follow_symlinks>("follow_symlinks")
            ;
    }
};

template <> struct qjs::js_traits<breeze::js::filesystem::MkDirOptions> {
    static breeze::js::filesystem::MkDirOptions unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::filesystem::MkDirOptions obj;

        obj.recursive = js_traits<bool>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "recursive"));

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::filesystem::MkDirOptions &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        JS_SetPropertyStr(ctx, obj, "recursive", js_traits<bool>::wrap(ctx, val.recursive));

        return obj;
    }
};
template<> struct js_bind<breeze::js::filesystem::MkDirOptions> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::filesystem::MkDirOptions>("filesystem::MkDirOptions")
            .constructor<>()
                .fun<&breeze::js::filesystem::MkDirOptions::recursive>("recursive")
            ;
    }
};

template <> struct qjs::js_traits<breeze::js::filesystem::RmOptions> {
    static breeze::js::filesystem::RmOptions unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::filesystem::RmOptions obj;

        obj.recursive = js_traits<bool>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "recursive"));

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::filesystem::RmOptions &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        JS_SetPropertyStr(ctx, obj, "recursive", js_traits<bool>::wrap(ctx, val.recursive));

        return obj;
    }
};
template<> struct js_bind<breeze::js::filesystem::RmOptions> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::filesystem::RmOptions>("filesystem::RmOptions")
            .constructor<>()
                .fun<&breeze::js::filesystem::RmOptions::recursive>("recursive")
            ;
    }
};

template <> struct qjs::js_traits<breeze::js::infra> {
    static breeze::js::infra unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::infra obj;

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::infra &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        return obj;
    }
};
template<> struct js_bind<breeze::js::infra> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::infra>("infra")
            .constructor<>()
                .static_fun<&breeze::js::infra::sleep>("sleep")
                .static_fun<&breeze::js::infra::sleepSync>("sleepSync")
                .static_fun<&breeze::js::infra::setTimeout>("setTimeout")
                .static_fun<&breeze::js::infra::setInterval>("setInterval")
                .static_fun<&breeze::js::infra::clearTimeout>("clearTimeout")
                .static_fun<&breeze::js::infra::clearInterval>("clearInterval")
                .static_fun<&breeze::js::infra::atob>("atob")
                .static_fun<&breeze::js::infra::btoa>("btoa")
            ;
    }
};

template <> struct qjs::js_traits<breeze::js::infra::URLSearchParams> {
    static breeze::js::infra::URLSearchParams unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::infra::URLSearchParams obj;

        obj.list = js_traits<std::vector<std::pair<std::string, std::string>>>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "list"));

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::infra::URLSearchParams &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        JS_SetPropertyStr(ctx, obj, "list", js_traits<std::vector<std::pair<std::string, std::string>>>::wrap(ctx, val.list));

        return obj;
    }
};
template<> struct js_bind<breeze::js::infra::URLSearchParams> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::infra::URLSearchParams>("infra::URLSearchParams")
            .constructor<>()
                .fun<&breeze::js::infra::URLSearchParams::size>("size")
                .fun<&breeze::js::infra::URLSearchParams::append>("append")
                .fun<&breeze::js::infra::URLSearchParams::remove>("remove")
                .fun<&breeze::js::infra::URLSearchParams::get>("get")
                .fun<&breeze::js::infra::URLSearchParams::getAll>("getAll")
                .fun<&breeze::js::infra::URLSearchParams::has>("has")
                .fun<&breeze::js::infra::URLSearchParams::set>("set")
                .fun<&breeze::js::infra::URLSearchParams::sort>("sort")
                .fun<&breeze::js::infra::URLSearchParams::toString>("toString")
                .fun<&breeze::js::infra::URLSearchParams::list>("list")
            ;
    }
};

template <> struct qjs::js_traits<breeze::js::infra::URL> {
    static breeze::js::infra::URL unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::infra::URL obj;

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::infra::URL &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        return obj;
    }
};
template<> struct js_bind<breeze::js::infra::URL> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::infra::URL>("infra::URL")
            // .constructor<>()
                .constructor<const std::string &>()
                .property<&breeze::js::infra::URL::get_href, &breeze::js::infra::URL::set_href>("href")
                .property<&breeze::js::infra::URL::get_protocol, &breeze::js::infra::URL::set_protocol>("protocol")
                .property<&breeze::js::infra::URL::get_username, &breeze::js::infra::URL::set_username>("username")
                .property<&breeze::js::infra::URL::get_password, &breeze::js::infra::URL::set_password>("password")
                .property<&breeze::js::infra::URL::get_host, &breeze::js::infra::URL::set_host>("host")
                .property<&breeze::js::infra::URL::get_hostname, &breeze::js::infra::URL::set_hostname>("hostname")
                .property<&breeze::js::infra::URL::get_port, &breeze::js::infra::URL::set_port>("port")
                .property<&breeze::js::infra::URL::get_pathname, &breeze::js::infra::URL::set_pathname>("pathname")
                .property<&breeze::js::infra::URL::get_search, &breeze::js::infra::URL::set_search>("search")
                .property<&breeze::js::infra::URL::get_searchParams>("searchParams")
                .property<&breeze::js::infra::URL::get_hash, &breeze::js::infra::URL::set_hash>("hash")
                .static_fun<&breeze::js::infra::URL::parse>("parse")
                .static_fun<&breeze::js::infra::URL::canParse>("canParse")
                .fun<&breeze::js::infra::URL::origin>("origin")
                .fun<&breeze::js::infra::URL::toJSON>("toJSON")
            ;
    }
};

template <> struct qjs::js_traits<breeze::js::test> {
    static breeze::js::test unwrap(JSContext *ctx, JSValueConst v) {
        breeze::js::test obj;

        return obj;
    }

    static JSValue wrap(JSContext *ctx, const breeze::js::test &val) noexcept {
        JSValue obj = JS_NewObject(ctx);

        return obj;
    }
};
template<> struct js_bind<breeze::js::test> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<breeze::js::test>("test")
            .constructor<>()
                .static_fun<&breeze::js::test::testAsync>("testAsync")
            ;
    }
};

inline void bindAll(qjs::Context::Module &mod) {

    js_bind<breeze::js::filesystem>::bind(mod);

    js_bind<breeze::js::filesystem::ReadDirOptions>::bind(mod);

    js_bind<breeze::js::filesystem::MkDirOptions>::bind(mod);

    js_bind<breeze::js::filesystem::RmOptions>::bind(mod);

    js_bind<breeze::js::infra>::bind(mod);

    js_bind<breeze::js::infra::URLSearchParams>::bind(mod);

    js_bind<breeze::js::infra::URL>::bind(mod);

    js_bind<breeze::js::test>::bind(mod);

}
