import { ClangASTD } from "./clang-ast";
import { existsSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { CTypeParser, cTypeToTypeScript } from "./c-type-parser";

let text = readFileSync(join(__dirname, 'ast.json'), 'utf-8');
text = '[' + text.replaceAll('}\n{', '},{') + ']';
const astArr = JSON.parse(text) as ClangASTD[];

const targetFile = 'binding_types.h'
const outputFile = 'binding_qjs.h'
// filter out loc.file contains targetFile

const origFile = readFileSync(join(__dirname, '../../src/shell/script/binding_types.h'), 'utf-8').split('\n').map(v => v.trim())

let binding =
    `// This file is generated by scripts/bindgen/index.ts
// Do not modify this file manually!

#pragma once
#include "binding_types.h"
#include "quickjs.h"
#include "quickjspp.hpp"

template <typename T>
struct js_bind {
    static void bind(qjs::Context::Module &mod) {}
};
`

let typescriptDef = `// This file is generated by scripts/bindgen/index.ts
// Do not modify this file manually!

declare module 'mshell' {

`

const parseFunctionQualType = (type: string) => {
    // std::variant<int, std::string> (std::string, std::string)
    // std::function<void(int, std::string)> (int, std::string)

    enum State {
        ReturnType,
        Args,
        Done
    }

    let state = State.ReturnType;
    let returnType = '';
    let currentArg = '';
    let args: string[] = [];
    let depth = 0;
    let angleBracketDepth = 0;

    for (let i = 0; i < type.length; i++) {
        const char = type[i];

        if (char === '<') {
            angleBracketDepth++;
        } else if (char === '>') {
            angleBracketDepth--;
        }

        switch (state) {
            case State.ReturnType:
                if (char === '(' && angleBracketDepth === 0) {
                    state = State.Args;
                    returnType = returnType.trim();
                } else {
                    returnType += char;
                }
                break;

            case State.Args:
                if (char === '(') depth++;
                if (char === ')') {
                    if (depth === 0 && angleBracketDepth === 0) {
                        if (currentArg.trim()) args.push(currentArg.trim());
                        state = State.Done;
                        break;
                    }
                    depth--;
                }
                if (char === ',' && depth === 0 && angleBracketDepth === 0) {
                    args.push(currentArg.trim());
                    currentArg = '';
                } else {
                    currentArg += char;
                }
                break;
        }
    }

    if (state !== State.Done) {
        throw new Error('Invalid function type');
    }

    return {
        returnType,
        args
    };
}


const structNames: string[] = []

const resolveUnderPath = (path: string[], resolveName: string) => {
    const ns = path.join('::');
    const fullName = `${ns}::${resolveName}`;
    if (structNames.includes(fullName)) {
        return fullName;
    }

    // If not found, we try to find the name under the parent namespace
    if (path.length > 1) {
        const parentPath = path.slice(0, -1);
        const parentFullName = resolveUnderPath(parentPath, resolveName);
        if (parentFullName) {
            return parentFullName;
        }
    }

    // else we return the name as is
    return resolveName;
}

const ctypeToQualified = (type: string, path: string[]) => {
    const parser = new CTypeParser();
    const parsed = parser.parse(type, name => {
        return resolveUnderPath(path, name)
    });

    return parser.formatToC(parsed);
}

const nameFilter = "breeze::js::";

const generateForRecordDecl = (node_struct: ClangASTD, path: string[]) => {
    if (node_struct.kind !== 'CXXRecordDecl') {
        throw new Error('Node is not a RecordDecl');
    }

    const structName = node_struct.name;

    const fields: {
        name: string;
        type: string;
        comment?: string;
    }[] = [];

    const methods: {
        name: string;
        returnType: string;
        args: string[];
        static: boolean;
        comment?: string;
        argNames?: string[];
    }[] = [];

    const bases: {
        access: 'public' | 'protected' | 'private';
        type: string;
    }[] = node_struct.bases?.filter(base => {
        return !base.type.qualType.includes('std::')
    }).map(base => {
        return {
            access: base.access,
            type: ctypeToQualified(base.type!.qualType, path)
        };
    }) as any || [];

    if (!node_struct.inner) return;

    for (const node of node_struct.inner) {
        if (node.name?.startsWith('$')) continue;

        const lineNum = node.loc?.line;
        // 1. Parse comments
        let comment = '';

        if (lineNum) {
            let rangeCommentCnt = 0;
            for (let i = lineNum - 2; i >= 0; i--) {
                const line = origFile[i];
                if (!line) continue;
                if (line.startsWith('//')) {
                    comment = line.substring(2) + '\n' + comment;
                    continue;
                }
                if (line.startsWith('/*')) {
                    rangeCommentCnt++;
                }
                if (line.endsWith('*/')) {
                    rangeCommentCnt--;
                }

                if (rangeCommentCnt === 0) break;
                else comment = line.replaceAll('/*', '').replaceAll('*/', '*')
                    + '\n' + comment;
            }
        }

        // 2. Parse fields, methods
        if (node.kind === 'FieldDecl') {
            fields.push({
                name: node.name!,
                type: ctypeToQualified(node.type!.qualType, path),
                comment: comment.length > 0 ? comment : undefined
            });
        }

        if (node.kind === 'CXXMethodDecl') {
            const parsed = parseFunctionQualType(node.type!.qualType);

            if (
                ['operator='].includes(node.name!)
            ) continue;

            const argNames: string[] = [];
            if (node.inner) {
                for (const arg of node.inner) {
                    if (arg.kind === 'ParmVarDecl') {
                        argNames.push(arg.name!);
                    }
                }
            }

            methods.push({
                name: node.name!,
                returnType: ctypeToQualified(parsed.returnType, path),
                args: parsed.args.map(arg => ctypeToQualified(arg, path)),
                static: node.storageClass === 'static',
                comment: comment.length > 0 ? comment : undefined,
                argNames
            });
        }
    }

    const fullName = path.join('::') + '::' + structName;

    // 1. transform traits as value
    // We generate this only if there are no bases
    if (bases.length === 0) {
        binding += `
template <> struct qjs::js_traits<${fullName}> {
    static ${fullName} unwrap(JSContext *ctx, JSValueConst v) {
        ${fullName} obj;
    `;

        for (const field of fields) {
            binding += `
        obj.${field.name} = js_traits<${field.type}>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "${field.name}"));
        `;
        }

        binding += `
        return obj;
    }

    static JSValue wrap(JSContext *ctx, const ${fullName} &val) noexcept {
        JSValue obj = JS_NewObject(ctx);
    `;

        for (const field of fields) {
            binding += `
        JS_SetPropertyStr(ctx, obj, "${field.name}", js_traits<${field.type}>::wrap(ctx, val.${field.name}));
        `;
        }

        binding += `
        return obj;
    }
};`;
    }


    const hasNamespace = fullName === nameFilter + structName;
    const jsNamespaceName = fullName.replace(nameFilter, '');

    // 2. transform traits as class pointer
    binding += `
template<> struct js_bind<${fullName}> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<${fullName}>("${jsNamespaceName}")
            .constructor<>()`;

    // according to https://github.com/ftk/quickjspp/blob/master/test/inheritance.cpp
    // we only need to bind one base if there are multiple bases
    // although idk why
    if (bases.length > 0) {
        binding += `
                .base<${bases[0].type}>()`;
    }

    for (const method of methods) {
        if (method.static) {
            binding += `
                .static_fun<&${fullName}::${method.name}>("${method.name}")`;
        } else {
            binding += `
                .fun<&${fullName}::${method.name}>("${method.name}")`;
        }
    }

    for (const field of fields) {
        binding += `
                .fun<&${fullName}::${field.name}>("${field.name}")`;
    }

    binding += `
            ;
    }

};
    `;


    typescriptDef += `
${hasNamespace ? '' : `namespace ${jsNamespaceName.split("::").slice(0, -1).join('.')} {`}
export class ${structName}${bases.length > 0 ? ` extends ${bases.map(base => base.type.split('::').pop() ?? base.type).join(', ')}` : ''
        } {
\t${fields.map(field => {
            let fieldDef = `${field.name}${field.type.startsWith('std::optional') ? '?' : ''
                }: ${cTypeToTypeScript(field.type, nameFilter)}`;

            if (field.comment) {
                fieldDef = `
  /**
  * ${field.comment.trim().split('\n').join('\n  * ')}
  */
  ${fieldDef}
            `
            }

            return fieldDef;
        }).join('\n\t')}
\t${methods.map(method => {
            let methodDef = `${method.static ? 'static ' : ''}${method.name}: ${cTypeToTypeScript(`${method.returnType}(${method.args.join(', ')})`, nameFilter)}`

            // if (method.comment) {
            //     methodDef = method.comment.trim().split('\n').map(v => `// ${v}`).join('\n\t')
            //         + '\n\t' + methodDef;
            // }

            // if (method.argNames) {
            //     methodDef = '// Args: ' + method.argNames.join(', ') + '\n\t' + methodDef;
            // }
            let comments = '';
            if (method.comment) {
                comments += method.comment.trim();
            }
            methodDef = `
/**
  * ${comments.split('\n').join('\n  * ')}
  * @param ${method.args.map((arg, i) => `${method.argNames![i]}: ${cTypeToTypeScript(arg, nameFilter)}`).join(', ')}
  * @returns ${cTypeToTypeScript(method.returnType, nameFilter)}
  */
  ${methodDef}
            `
            return methodDef;
        }).join('\n\t')}
}
${hasNamespace ? '' : `}\n`}`;

}


const enumerateStructDecls = (node: ClangASTD, callback, path: string[] = ['breeze']) => {
    if (node.kind === 'CXXRecordDecl') {
        if (node.name && node.inner) {
            callback(node, path);
        }
    }

    if (node.inner) {
        for (const child of node.inner) {
            enumerateStructDecls(child, callback, [...path, node.name || '']);
        }
    }
}

for (const ast of astArr)
    enumerateStructDecls(ast, (node, path) => {
        structNames.push(path.join('::') + '::' + node.name!);
    })

for (const ast of astArr)
    enumerateStructDecls(ast, (node, path) => {
        if (node.kind === 'CXXRecordDecl') {
            generateForRecordDecl(node, path);
        }
    })


binding += `
inline void bindAll(qjs::Context::Module &mod) {
`

for (const structName of structNames) {
    binding += `
    js_bind<${structName}>::bind(mod);
`
}

binding += `
}
`

typescriptDef += `
}
`

declare var __dirname: string;
const paths = [
    join(__dirname, 'src/shell/script'),
    join(__dirname, '../src/shell/script'),
    join(__dirname, '../../src/shell/script')
]

typescriptDef += readFileSync(join(__dirname, 'quickjs-types.txt'), 'utf-8');

for (const path of paths) {
    try {
        if (existsSync(join(path, targetFile))) {
            writeFileSync(join(path, outputFile), binding);
            writeFileSync(join(path, 'binding_types.d.ts'), typescriptDef);
            break;
        }
    } catch (e) {
        console.error(e);
    }
}

rmSync(join(__dirname, 'ast.json'));